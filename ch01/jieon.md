# 1. 단일 서버

> 모든 컴포넌트가 단 한 대의 서버에서 실행되는 간단한 시스템
> 
- 웹 앱, DB, 캐시 등이 전부 서버 한 대에서 실행

![image](https://github.com/user-attachments/assets/50e57ccf-3440-4791-8106-3e9eadc2d501)

# 2. 데이터베이스

> 사용자 증가에 따라 데이터베이스용 서버 추가
> 
- 웹/모바일 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층) 분리
- 각각 독립적으로 확장 가능

![image](https://github.com/user-attachments/assets/ee02ad8d-40c6-40c7-a4d3-629d07071e1c)

## 데이터베이스 선택 기준

### 관계형 데이터베이스 : Relational Database

> 자료를 테이블과 열, 칼럼으로 표현
> 
- SQL을 통해 여러 테이블에 있는 데이터를 관계에 따라 Join하여 합칠 수 있다.
- MySQL, Oracle, PostgreSQL

### 비 관계형 데이터베이스 : NoSQL

> NoSQL은 4 부류로 나눌 수 있다.
> 
1. 키-값 저장소 : Key-Value
2. 그래프 저장소 : Graph
3. 칼럼 저장소 : Column
4. 문서 저장소 : Document
- NoSQL은 일반적으로 Join 연산을 지원하지 않는다.
- 아래와 같은 경우, NoSQL 선택을 고려할 수 있다.
    - 아주 낮은 응답 지연시간(Latency)이 요구되는 경우
    - 다루는 데이터가 비정형인 경우
    - 데이터를 직렬화하거나 역직렬화 할 수 있기만 하면 되는 경우
    - 아주 많은 양의 데이터를 저장할 필요가 있는 경우

## 수직적 규모 확장 vs 수평적 규모 확장

### 수직적 규모 확장 : Scale-Up

> 기존 서버에 더 많은, 또는 고성능의 자원(CPU, RAM, 디스크 등)을 증설하는 방법
> 
- 서버로 유입되는 트래픽의 양이 적은 경우 좋은 방법

이러한 수직적 접근법에는 몇 가지 심각한 단점이 있다.

- 데이터베이스 서버 하드웨어에는 한계가 있으므로 CPU, RAM 등을 무한 증설할 수는 없다. 사용자가 계쏙 늘어나면 한 대 서버로는 결국 감당하기 어렵게 될 것이다.
- SPOF(Single Point of Failure)로 인한 위험성이 크다.
- 비용이 많이 든다. 고성능 서버로 갈수록 가격이 올라가는 것은 당연하다.

### 수평적 규모 확장 : Scale-Out

> 더 많은 서버를 추가함으로써 성능을 향상 시키는 방법
> 
- **샤딩(sharding)**이라고도 부른다.

### 두 방식의 차리

![image](https://github.com/user-attachments/assets/0eecad2e-46c3-4efe-8a18-02d3ba885aef)

## 로드밸런서

> 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할
> 
- 앞선 설계에서는 사용자와 웹 서버가 바로 연결되어 있어, 웹 서버가 다운되면 사용자는 웹 사이트 접속 불가

![image](https://github.com/user-attachments/assets/f37ae2e6-dc3d-4e71-83e9-d8d6de0a1d48)

- 사용자는 로드밸런서의 공개 IP 주소로 접근
    - 웹 서버가 클라이언트 접속을 직접 처리하는 구조가 아니다.
- 서버 간 통신에는 사설 IP 주소(Private IP address)를 사용
    - 사설 IP : 같은 네트워크에 속한 서버 사이의 통신에만 사용되는 IP 주소
    - 보안을 위함
    - 로드밸런서-웹 서버의 통신
- 장애를 자동복구하지 못하는 문제 해결
- 웹 계층의 가용성 향상

## 데이터베이스 다중화

> 데이터베이스 서버 사이에 주(Master)-부(Slave) 관계를 설정하고, 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식
> 
- 쓰기 연산(write)은 Master에서만 지원
- 읽기 연산(read)은 Slave에서만 지원
- 통상적으로 읽기 연산의 비중이 훨씬 높기 때문에, Slave 데이터베이스의 수가 더 많다.

### 장점

- 더 나은 성능
    - 병렬로 처리될 수 있는 질의(Query)의 수가 늘어나 성능이 좋아진다.
- 안정성
    - 모종의 이유로 DB 서버 가운데 일부가 파괴되어도 데이터가 보존된다.
- 가용성
    - 하나의 DB 서버에 장애가 발생하더라도 다른 서버를 이용함으로써 서비스를 유지할 수 있다.

![image](https://github.com/user-attachments/assets/470f665f-99eb-44cd-8aac-5b9f43aa0622)

# 3. 캐시

> 값비싼 연산이나 자주 참조되는 데이터를 메모리에 위치 시켜 요청의 속도를 올리는 방식
> 
- 응답시간(Latency) 개선

### 캐시 계층 : Cache Tier

> 데이터가 잠시 보관되는 곳
> 

![image](https://github.com/user-attachments/assets/d4273ea8-d036-4689-a3cd-429d00e06c89)

1. 데이터가 캐시에 있으면 캐시에서 데이터를 읽음
    1. 데이터가 캐시에 없으면 DB에서 해당 데이터를 읽어 캐시에 씀
2. 웹 서버에 데이터 반환

### 캐시 사용 시 유의할 점

1. 상황
    1. 데이터 갱신은 자주 일어나지 않지만, 참조가 빈번하게 일어나는 상황
2. 데이터 종류
    1. 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.
3. 데이터 만료
    1. 만료된 데이터를 캐시에서 삭제하는 정책
4. 일관성
    1. 데이터 저장소의 원본과 캐시 내의 사본의 일관성
5. 장애 처리
    1. 캐시 서버를 한 대만 두는 경우 해당 서버는 SPOF이 되어버릴 가능성이 있다.
    2. SPOF를 피하기 위해 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
6. 캐시의 크기
    1. 캐시 메모리가 너무 작으면 데이터가 캐시에서 자주 밀려, 캐시의 성능 저하의 요인이 된다.
7. 데이터 방출 정책
    1. 캐시가 가득찬 경우, 어떤 데이터를 내보내는가에 대한 정책
    2. LRU : 마지막으로 사용된 시점이 가장 오래된 데이터를 내보내는 정책
    3. LFU : 사용된 빈도가 가장 낮은 데이터를 내보내는 정책
    4. FIFO : 가장 먼저 캐시에 들어온 데이터를 내보내는 정책

# 4. 콘텐츠 전송 네트워크 : CDN

> 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크
> 
- 이미지, 비디오, CSS, JS 파일 등을 캐시할 수 있다.

## CDN 동작 방식

1. 사용자가 웹 사이트 방문
2. 이미지가 CDN에 없으면 원본 서버에서 가져옴
3. 가져온 이미지를 CDN에 저장
4. 해당 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달

## 고려 사항

- 비용
- 적절한 만료 시한 설정
- CDN 장애 대처 방안
- 콘텐츠 무효화 방법

![image](https://github.com/user-attachments/assets/c4919390-6811-4026-b947-e5abce36f4ad)

# 5. 무상태 웹 계층 : Stateless

> 상태 정보를 RDBMS나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 방법
> 
- 웹 계층을 수평적으로 확장하는 방법

### 상태 정보 의존적인 아키텍처

> 클라이언트 정보, 즉 상태를 유지해 요청들 사이에서 공유되도록 하는 방식
> 
- 이 경우, 서버 1에 사용자 A의 정보가 저장된다면, 서버 2에서는 사용자 A의 인증이 실패하게 된다.
- 즉, 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.
- 고정 세션이라는 기능을 통해 동작하지만, 로드밸런서에 부하가 갈 수 있다.

### 무상태 아키텍처

> 상태 정보가 필요할 경우, 공유 저장소로부터 데이터를 가져오는 방식
> 
- 상태 정보가 웹 서버로부터 물리적으로 분리되어 있다.
- 단순하고, 안정적이며, 규모 확장에 용이하다.

![image](https://github.com/user-attachments/assets/ef24aa0b-65d4-4e68-a185-18b77cac5617)

# 6. 데이터 센터

> 데이터 센터를 나누어 사용하는 방식
> 
- 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내된다.
    - 이 절차를 ‘지리적 라우팅(geoDNS-routing)’이라고 한다.
- 데이터 센터 중 하나에 장애가 발생한 경우, 모든 트래픽이 장애가 없는 데이터 센터로 전송

### 다중 데이터 센터의 기술적 난제

- 트래픽 우회
- 데이터 동기화
- 테스트 & 배포

# 7. 메시지 큐

> 메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트
> 
- 시스템을 더 큰 규모로 확장하기 위해 시스템의 컴포넌트를 분리해, 각기 독립적으로 확장될 수 있도록 하는 방식
- 메시지의 버퍼 역할
- 비동기적으로 전송
- 메시지의 생산자(Producer)가 메시지를 만들어 메시지 큐에 발행(Publish)하고, 소비자(Consumer)가 이를 받아 처리하는 방식
- 서비스 혹은 서버 간 결합이 느슨해진다.
    - 규모 확장성이 보장된다.

# 8. 로그, 메트릭, 자동화

# 9. 데이터베이스의 규모 확장

## 샤드(Shard)? 샤딩(Sharding)?

### 샤딩 : Sharding

> 대규모 데이터베이스를 **샤드(shard)**라고 부르는 작은 단위로 분할하는 기술
> 
- 데이터베이스에서 부하 분산을 위해 다수의 데이터베이스에 데이터를 분산 저장하는 기법이다.
- 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 **데이터 사이에는 중복이 없다**.

### 예시

아래의 그림은 샤드로 분할된 데이터베이스의 예이다. 

- 사용자 데이터를 어느 샤드에 넣을지는 사용자 ID에 따라 정한다.
- 이 예시에서는 user_id % 3을 해시 함수로 사용하여 데이터가 보관되는 샤드를 정한다.

![image](https://github.com/user-attachments/assets/73fd3acb-56cb-44dc-bbbf-fc2eb0c18ace)

또한, 아래는 각 샤드 노드에 사용자 데이터가 어떻게 보관되는지를 보여준다.

![image](https://github.com/user-attachments/assets/6c008feb-ed5e-4ada-af74-b0becf6aab56)

보이는 것처럼 샤드 간에 중복되는 데이터가 존재하지 않는다!

### 샤딩 키(Sharding Key)

샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것이 바로

> ***샤딩 키(sharding key)를 어떻게 정하느냐*** 하는 것이다.
> 
- 샤딩 키는 ***파티션 키***(partition key)라고도 부른다.
    - 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성된다.
    - 위 그림의 경우, 샤딩 키는 user_id이다.
- 샤딩 키를 통해 올바른 데이터베이스에 질의를 보내어 데이터 조회나 변경을 처리하므로 효율을 높일 수 있다. 이 샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는 게 가장 중요하다.

## 샤딩의 문제점

샤딩은 DB 규모 확장을 실현하는 휼륭한 기술이지만 완벽하지는 않다. 샤딩을 도입하면 시스템이 복잡해지고 풀어야 할 새로운 문제도 생긴다.

- 데이터의 재샤딩(resharding)
    - 재 샤딩은 다음과 같은 경우에 필요하다.
        - 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때
        - 샤드 간의 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때이 경우를 샤드 소진(shard exhaustion)이라고도 부르는데 이런 현상이 발생하면 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치 하여야 한다. 안정 해시(consistent hashing) 기법을 활용하면 이 문제를 해결할 수 있다.
        
- 유명인사(celebrity) 문제
    - 핫스팟 키(hotspot key) 문제라고도 부른다.
    - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제이다.
    - 예를 들어, BTS, 봉준호, 손흥민 같은 유명인사가 전부 같은 샤드에 저장되는 데이터베이스가 있다고 해 보자. 이 데이터로 사회 관계망 애플리케이션을 구축하게 되면 결국 해당 샤드에는 read 연산 때문에 과부하가 걸리게 될 것이다.
- 조인과 비정규화(join and de-normalization) : 일단 하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. 이를 해결하는 한 가지 방법은 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.
