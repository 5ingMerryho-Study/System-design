# 단일 서버

다음은 웹, 앱, 데이터베이스, 캐시 등을 하나의 서버에서 진행하는 경우이다.

![Image](https://github.com/user-attachments/assets/4a1e321c-e3e4-4031-a240-ab03fbff4954)

1\. 사용자가 도메인 이름(api.mysite.com)을 이용하여 요청

2\. DNS 서버의 응답을 받아 조회 결과로 IP 주소를 응답 받음

3\. 해당 IP 주소로 HTTP 요청 전달

4\. HTML 페이지나 JSON 형태의 응답을 반환 받음

이때, 사용자는 웹 애플리케이션 혹은 모바일 앱을 통해서 요청을 보낸다.

-   웹 애플리케이션 : 비즈니스 로직, 데이터 저장 등을 처리하기 위해 서버 구현용 언어(자바, 파이썬 등)을 사용하고, 프레젠테이션용으로클라이언트 구현용 언어(HTML, 자바스크립트 등)를 사용한다.
-   모바일 앱 : 모바일 앱과 웹 서버 간 통신을 위해 HTTP를 이용한다. HTTP를 통해 반환될 응답 데이터 포맷으로는 JSON이 많이 쓰인다.

## 데이터베이스

트래픽이 늘면 하나의 서버로는 충분하지 않을 수 있다. 따라서 기능별로 서버를 분리할 수 있는데, 웹/모바일 트래픽 처리(웹 계층)와 데이터베이스 서버(데이터 계층)으로 분리한다면 독립적으로 확장해나갈 수 있을 것이다.

![Image](https://github.com/user-attachments/assets/517cdddb-d13b-42f6-b822-bfef8f3a0ee0)

### 데이터베이스 선택

전통적인 관계형 데이터베이스(ralational database)와 비관계형 데이터베이스(non-relational database) 사이에서 선택할 수 있다.

#### 관계형 데이터베이스

관계형 데이터베이스는 관계형 데이터베이스 관리 시스템(RDBMS, Relational Database Management System)이라고도 불리는데, 이 중 유명한 것은 MySQL, Oracle DB, PostgreSQL 등이 있다.

자료를 테이블, 열, 컬럼으로 표현한다. 조인(join)을 이용하여 여러 테이블에 존재하는 데이터를 합칠 수 있다.

#### 비 관계형 데이터베이스

비 관계형 데이터베이스는 NoSQL이라고도 불린다. 대표적으로는 CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등이 있다.

NoSQL은 다시 4가지 분류로 나눌 수 있다.

-   키-값 저장소(key-value store)
-   그래프 저장소(graph store)
-   컬럼 저장소(column store)
-   문서 저장소(document store)

대부분의 경우 관계형 데이터베이스가 적절할 수 있지만, 다음의 경우는 NoSQL을 사용하는 것이 바람직할 수 있다.

-   아주 낮은 지연시간(latency)이 요구됨
-   다루는 데이터가 비정형(unstructured)이라 관계형이 아님
-   데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있기만 하면 됨
-   아주 많은 양의 데이터를 저장할 필요가 있음

## 수직적 규모 확장 vs 수평적 규모 확장

### 수직적 규모 확장의 한계

수직적 규모 확장 프로세스는 스케일 업(scale-up)이라고도 부른다. 이는 서버에 고사양 자원(더 좋은 CPU, 더 많은 RAM 등)을 추가하는 행위이다. 서버로 유입되는 트래픽 양이 적을 때는 좋은 선택일 수 있다.

다만, 수직적 규모 확장에는 한계가 있다. 한 대의 서버에 CPU나 메모리를 무한대로 확장할 수 없기 때문이다. 또한, 장애 발생 시 자동 복구나 다중화 방안을 제시하지 않는다. 서버에 장애가 발생하면 웹사이트/앱이 완전히 중단된다.

이런 단점 때문에, 대규모 애플리케이션을 지원하는 데는 수평적 규모 확장법이 적절하다.

너무 많은 사용자가 접속하여 웹 서버가 한계 상황에 도달하게 되면 응답 속도가 느려지거나 서버 접속이 불가능해질 수 있다. 따라서 부하 분산기 또는 로드밸런서를 도입하는 것이 최선이다.

### 로드밸런서

부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.

사용자는 로드밸런서의 공개 IP 주소(public IP address)로 접속한다. 따라서 웹 서버가 클라이언트의 접속을 직접 처리하지 않는다.

보안성을 위해 서버 간 통신에는 사설 IP 주소(private IP address, 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로, 인터넷을 통해서는 접속할 수 없다.)가 이용된다.

부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면 장애를 자동복구하지 못하는 문제(no failover)는 해소되며, 웹 계층의 가용성은 향상된다.

### 데이터베이스 다중화

많은 데이터베이스 관리 시스템은 다중화를 지원한다. 보통은 서버 사이에 주(master)-부(slave) 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다.

쓰기 연산(write operation)은 마스터에서만 지원한다. 대부분의 애플리케이션은 쓰기 연산보다 읽기 연산의 비중이 높기 때문에 부 데이터베이스는 주 데이터베이스로부터 사본을 전달받아, 읽기 연산(read operation)만을 지원한다. 데이터베이스를 수정하는 명령어들(insert, delete, update 등)은 주 데이터베이스로만 전달되어야 한다.

![Image](https://github.com/user-attachments/assets/80099910-3dcd-4658-97a4-4414c4f02c2a)

데이터베이스 다중화의 이득은 다음과 같다.

-   더 나은 성능 : 주-부 다중화 모델에서 변경 연산과 읽기 연산을 나누어 병렬로 처리하여 성능이 좋아진다.
-   안정성(reliability) : 데이터베이스 서버 일부가 파괴되어도 데이터가 보존된다.
-   가용성(availability) : 데이터를 여러 지역에 복제하여 하나의 서버에 장애가 발새하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스할 수 있게 된다.

만약, 데이터베이스 서버 가운데 하나가 다운되면 무슨 일이 벌어질까?

**부 데이터베이스 서버가 다운되는 경우**

-   부 서버가 한 대 뿐인데 다운된 경우라면, 읽기 연산은 한시적으로 모두 주 데이터베이스로 전달될 것이다. 또한 즉시 새로운 부 데이터베이스 서버가 장애 서버를 대체할 수 있다.

**주 데이터베이스 서버가 다운되는 경우**

-   주 데이터베이스 서버가 다운되면, 한 대의 부 데이터베이스만 있는 경우 해당 부 데이터베이스 서버가 새로운 주 서버가 될 것이고, 모든 데이터베이스 연산은 일시적으로 새로운 주 서버상에서 수행될 것이다. 그리고 새로운 부 서버가 추가될 것이다.
-   프로덕션(production) 환경에서 벌어지는 일은 이것보다는 복잡하다. 부 서버에 보관된 데이터가 최신 상태가 아닐 수 있기 때문이다. 없는 데이터는 복구 스크립트를 돌려서 추가하고, 다중 마스터나 원형 다중화 방식을 도입하면 도움이 될 수 있지만 복잡하다.

![Image](https://github.com/user-attachments/assets/048c1f86-15e2-47c0-a7d0-c560bd54626a)

### 캐시

캐시 : 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소

#### 캐시 계층

캐시 계층(cache tier)은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다. 성능과 데이터베이스의 부하를 최적화할 수 있다.

![Image](https://github.com/user-attachments/assets/7b14e4d7-0a75-43fb-a08d-e96dbcf688f0)

캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하여 사용할 수 있다.

#### 캐시 사용 시 유의할 점

-   데이터 **갱신은 자주 일어나지 않지만** **참조는 빈번**하게 일어난다면 **캐시 적용을 고려**해볼 만하다.
-   캐시는 데이터를 휘발성 메모리에 두므로, **영속적으로 보관할** **데이터를 캐시에 두는 것은 바람직하지 않다**. 중요한 데이터는 지속적 저장소(persistent data store)에 두어야 한다.
-   **캐시에 보관된 데이터가 어떻게 만료될 지에 대한 정책을 마련**해 두는 것은 권장된다. 너무 짧아도 데이터베이스를 너무 자주 읽어, 캐시를 도입한 효과가 떨어질 것이고, 너무 길어도 원본과 차이가 날 가능성이 높아질 수 있다.
-   **데이터 저장소의 원본과 캐시 내의 사본에 대한 일관성을 유지하는 것이 중요**하다. 원본 갱신 연산과 캐시 경신 연산이 단일 트랜잭션으로 처리되지 않는 경우를 경계해야 한다.
-   캐시 서버를 한 대만 두는 경우 해당 서버는 단일 장애 지점(SPOF, Single Point of Failure)이 되어버릴 가능성이 있다. 따라서 **SPOF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산**시켜야 한다.
-   **캐시 메모리의 크기를 적절하게 잡아** 액세스 패턴에 따라 **데이터가 캐시에서 너무 자주 밀려나지 않도록** 해야한다. 메모리 과할당이 방법이 될 수 있다.
-   캐시가 꽉 차버려서 추가로 데이터를 넣어야할 경우 정책에 따라 데이터 방출을 해야한다.

### 콘텐츠 전송 네트워크(CDN)

CDN은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. 클라이언트와 서버가 지리적으로 멀리 떨어져있는 경우, 물리적으로 가까운 위치의 CDN에서 응답을 전달하여 응답시간을 개선할 수 있다.

**CDN 사용 시 고려해야 할 사항**

-   비용 : CDN은 보통 제3 사업자에 의해 운영되며 데이터의 전송 양에 따라 요금을 내게 된다. 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않다. 따라서 CDN에서 빼는 것이 권장된다.
-   적절한 만료 시한 설정 : 시의성이 중요한 콘텐츠의 경우 만료 시점을 잘 정해야 한다.
-   CDN 장애에 대한 대처 방안 : CDN 자체가 죽었을 경우 웹사이트/애플리케이션이 어떻게 동작해야 하는지 고려해야 한다.

CDN을 적절하게 사용한다면 정적 콘텐츠를 제공할 때 더 나은 성능을 보장할 수 있다. 또한, 캐시되어 데이터베이스 부하를 줄여준다.

### 무상태(stateless) 웹 계층

웹 계층을 **수평적으로 확장하기 위해**서는 **상태 정보(사용자 세션 데이터 등)를 웹 계층에서 제거**해야 한다. 책에서 권장하는 전략은 상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 것이다.

이렇게 **상태 정보를 제거한 것을 무상태 웹 계층**이라 부른다.

#### 상태 정보 의존적인 아키텍처와 무상태 아키텍처

상태 정보 의존적인 아키텍처는 각 서버마다 별도의 정보를 저장하게 되어, 상태 정보를 이용한 요청이 성공하기 위해서는 반드시 같은 서버에 요청을 보내야 한다. 그렇지 않다면 로드밸런서의 고정 세션(sticky session) 기능을 이용할 수 있는데, 이는 로드밸런서에 부담을 준다.

하지만 무상태 아키텍처를 적용하면 HTTP 요청은 어떤 웹 서버로도 전달할 수 있다. 상태 정보가 필요한 경우 공유 저장ㅅ로부터 데이터를 가져와서 사용할 수 있기 때문이다.

![Image](https://github.com/user-attachments/assets/ce149cc4-d551-4750-9caa-42dc48a0bc28)

### 데이터 센터

만약, 여러 개의 데이터 센터를 이용하는 사례가 있다고 생각해보자. 장애가 없다면 사용자는 가장 가까운 데이터 센터로 안내될 것이다. 이러한 절차를 지리적 라우팅(geoDNS-routing)이라 부른다.

geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해준다.

하지만, 데이터 센터 중 하나에 심각한 장애가 발생하면 모든 트래픽이 장애가 없는 데이터 센터로 전송될 것이고, 몇 가지 기술적 난제를 해결해야 한다.

-   트래픽 우회 : 올바른 데이터 센터로 드래픽을 보내는 효과적인 방법을 찾아야 한다.
-   데이터 동기화 : 데이터 센터마다 별도의 DB를 사용하고 있는 상황이라면, 장애가 자동으로 복구되어 트래픽이 다른 DB로 우회된다 해도 해당 DB에는 찾는 데이터가 없을 수 있다.
-   테스트와 배포 : 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트하여 동일한 서비스가 설치되도록 보장해야 한다.

### 메시지 큐

메시지 큐는 메시지의 무손실(durability, 메시지 큐에 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성)을 보장하는, 비동기 통신을 지원하는 컴포넌트다.

![Image](https://github.com/user-attachments/assets/9200b1a7-0c5d-424c-ba68-2c312116157c)

메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구선하기 좋다.

이미지 크로핑, 샤프닝, 블러링 등 시간이 오래 걸릴 수 있는 작업을 비동기적으로 처리하면 편리하다.

### 데이터베이스의 규모 확장

#### 수직적 확장

스케일 업이라고도 부르는 수직적 규모 확장법은 기존 서버에 더 많은, 또는 고성능의 자원(CPU, RAM, 디스크 등)을 증설하는 방법이다. 다만, 다음의 약점이 있다.

-   하드웨어에는 한계가 있으므로 무한으로 증설할 수는 없다.
-   SPOF(Single Point of Failure)로 인한 위험성이 크다.
-   비용이 많이 든다. 고성능의 서버로 갈수록 가격이 올라가기 때문이다.

#### 수평적 확장

DB의 수평적 확장은 샤딩(sharding)이라고도 부르는데, 더 많은 서버를 추가하여 성능을 향상시킬 수 있도록 한다.

샤딩은 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술을 일컫는다.

모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

![Image](https://github.com/user-attachments/assets/ff8f967b-77ef-4fac-a847-830a9a5eb02c)

샤딩 전략을 구현할 때 고려해야할 가장 중요한 것은 샤딩 키(sharding key 혹은, partition key)를 어떻게 정하느냐는 것이다. 샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는 게 가장 중요하다.

하지만, 다름의 문제가 생길 수 있다.

-   데이터의 재 샤딩(resharding) : 데이터가 너무 많아져, 하나의 샤드로는 더 이상 감당하기 어려울 때, 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때 재 샤딩이 필요하다.
-   유명인사(celebrity) 문제 : 핫스팟 키(hotspot key) 문제라고도 부르는데, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제이다. 자주 읽히는 특정 키가 하나의 샤드에 집중된다면 해당 샤드에 read 연상 때문에 과부하가 걸릴 수 있다.
-   조인과 비정규화 : 일단 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. DB를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하여 해결할 수도 있다.

## 정리

서비스 규모에 따라 달라지겠지만, 대규모 서비스를 안정적이고 효율적으로 운영하기 위한 내용을 정리하자면, 다음과 같다.

-   웹 계층은 무상태 계층으로
-   모든 계층에 다중화 도입
-   가능한 한 많은 데이터를 캐시할 것
-   여러 데이터 센터를 지원할 것
-   여러 데이터 센터를 지원할 것
-   정적 콘텐츠는 CDN을 통해 서비스할 것
-   데이터 계층은 샤딩을 통해 그 규모를 확장할 것
-   각 계층은 독립적 서비스로 분할할 것
-   시스템을 지속적을 모니터링하고, 자동화 도구들을 활용할 것

[대규모 시스템 설계 기초 | 1장 : 사용자 수에 따른 규모 확장성](https://i-am-strong-man.tistory.com/354)
