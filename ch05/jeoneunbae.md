# 안정 해시 설계

수평적 규모 확장성을 달성하기 위해서는 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요하다.

'안정 해시'는 이 목표를 달성하기 위해 보편적으로 사용하는 기술이다.

## 해시 키 재배치(rehash) 문제

N개의 캐시 서버가 있을 때, 이 서버들에 부하를 균등하게 나누는 보편적 방법은 해시 함수를 사용하는 것이다.

### 해시 함수
serverIndex = hash(key) % N (N은 서버의 개수)

총 4대의 서버를 사용할 때 예제를 보겠다.

주어진 각각의 키에 대해서 해시 값과 서버 인덱스를 계산한 예제이다.

|키|해시|해시 % 4 (서버 인덱스)|
|---|---|:---:|
|key0|18358617|1|
|key1|26143584|0|
|key2|18131146|2|
|key3|35863496|0|
|key4|34085809|1|
|key5|27581703|3|
|key6|38164978|2|
|key7|22530351|3|

특정한 키가 보관된 서버를 알아내기 위해, 나머지(modular) 연산을 f(key) % 4 와 같이 적용한다.

키 값이 서버에 어떻게 분산되는지는 그림을 통해 알 수 있다.

![image](https://github.com/user-attachments/assets/bb8f55da-6b80-4147-bd02-28920cf1b5d7)

이 방법은 서버 풀(server pool)의 크기가 고정되어 있을 때, 그리고 데이터 분포가 균등할 때는 잘 동작한다.

하지만 서버가 추가되거나 기존 서버가 삭제되면 문제가 생긴다.

예를 들어 1번 서버가 장애를 일으켜 동작을 중단했다고 했을 때, 서버 풀의 크기는 3으로 줄어든다.

그 결과로, 키에 대한 해시 값은 변하지 않지만 나머지(%) 연산을 적용하여 계산한 서버 인덱스 값은 달라질 것이다.

![image](https://github.com/user-attachments/assets/c8707d72-62b2-4918-a5ea-b61e3eab11f4)

장애가 발생한 1번 서버에 보관되어 있는 키 뿐만 아닌 대부분의 키가 재분배되었다.

1번 서버가 죽으면 대부분 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 된다는 뜻이다.

그 결과로 대규모 캐시 미스(cache miss)가 발생하게 될 것이다.

안정 해시는 이 문제를 효과적으로 해결하는 기술이다.

## 안정 해시

"안정 해시"는 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술이다.

여기서 k는 키의 개수이고, n은 슬롯(slot)의 개수다.

이와는 달리 대부분의 전통적 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분 키를 재배치한다.

## 해시 공간과 해시 링

안정 해시의 동작 원리를 살펴본다.

해시 함수 f로는 SHA-1을 사용한다고 하고, 그 함수의 출력 값 범위는 x0, x1, x2, x3, ... xn과 같다.

SHA-1의 해시 공간(hash space) 범위는 0부터 2^160 - 1 까지이다.

따라서 x0는 0, xn은 2^160 - 1 이며, 나머지 x1부터 xn - 1까지는 그 사이의 값을 갖게 될 것이다.

이 해시 공간을 링으로 만들면 해시 링이 만들어진다.

### 해시 서버

4개의 서버를 해시 링에 배치하면 그림과 같다.

![image](https://github.com/user-attachments/assets/fae6f665-43fb-42ba-8b96-c05556697015)

### 해시 키

캐시할 키 key0, key1, key2, key3는 해시 링 위의 어느 지점에 배치할 수 있다.

![image](https://github.com/user-attachments/assets/d2b049b4-9253-4955-b1b1-7bf0b13f9737)

### 서버 조회

어떤 키가 저장되는 서버는, 해당 키의 위치로부터 시계 방향으로 링을 탐색해나가면서 만나는 첫 번째 서버다.

따라서 key0는 서버0, key1은 서버1에 저장되며, key2는 서버2, key3은 서버3에 저장된다.

![image](https://github.com/user-attachments/assets/1c007ca2-81e3-4f7e-bf6c-ba2e274bbb81)

### 서버 추가

서버를 추가하더라도 키 가운데 일부만 재배치하면 된다.

다른 키들은 재배치되지 않지만 추가된 서버를 만나는 키만 재배치하면 된다.

![image](https://github.com/user-attachments/assets/4008b30c-3309-4c10-a739-3dd4d1336853)

### 서버 제거

하나의 서버가 제거되면 키 가운데 일부만 재배치된다.

나머지 키에는 영향이 없다.

![image](https://github.com/user-attachments/assets/7ce243ce-55cc-4d88-8fd0-23bc81ccc0de)

### 기본 구현법의 두 가지 문제

안정 해시 알고리즘의 기본 절차는 다음과 같다.

- 서버와 키를 균등 분포(uniform distribution) 해시 함수를 사용해 해시 링에 배치한다.
- 키의 위치에서 링을 시계 방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버다.

이 접근법에는 두 가지 문제가 있다.

서버가 추가되거나 삭제되는 상황을 감안하면 파티션(partition)의 크기를 균등하게 유지하는 게 불가능하다는 것이 첫번째 문제다.

여기서 파티션은 인접한 서버 사이의 해시 공간이다.

어떤 서버는 굉장히 작은 해시 공간을 할당 받고, 어떤 서버는 굉장히 큰 해시 공간을 할당 받는 상황이 가능하다는 것이다.

두 번째 문제는 키의 균등 분포를 달성하기가 어렵다는 것이다.

이 문제를 해결하기 위해 제안된 기법이 '가상 노드(virtual node)' 또는 '복제(replica)'라 불리는 기법이다.

## 가상 노드

가상 노드(virtual node)는 실제 노드 또는 서버를 가리키는 노드로서, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.

서버0과 서버1은 3개의 가상 노드를 갖는다.

따라서 각 서버는 하나가 아닌 여러 개 파티션을 관리해야 한다.

![image](https://github.com/user-attachments/assets/8a162e2f-ca6b-471b-83a0-60ff5a2970b4)

키의 위치로부터 시계방향으로 링을 탐색하다 만나는 최초의 가상 노드가 해당 키가 저장될 서버가 된다.

가상 노드의 개수를 늘리면 키의 분포는 점점 더 균등해진다.

표준 편차(standard deviation)가 작아져서 데이터가 고르게 분포되기 때문이다.

표준 편차는 데이터가 어떻게 퍼져 나갔는지를 보이는 척도다.

가상 노드의 개수를 더 늘리면 표준 편차의 값은 더 떨어진다.

그러나 가상 노드 데이터를 저장할 공간은 더 많이 필요하게 될 것이다.

타협적 결정(tradeoff)이 필요하다는 뜻이다.

그러니 시스템 요구사항에 맞도록 가상 노드 개수를 적절히 조정해야 할 것이다.

## 마무리

이번 장은 안정 해시가 왜 필요하며 어떻게 동작하는지를 살펴보았다.

안정 해시의 이점은 다음과 같다.

- 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
- 데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다.
- 핫스팟(hotspot) 키 문제를 줄인다. <br> 특정한 샤드(shard)에 대한 접근이 지나치게 빈번하면 서버 과부하 문제가 생길 수 있다. <br> 안정 해시는 데이터를 좀 더 균등하게 분배하므로 이런 문제가 생길 가능성을 줄인다.
