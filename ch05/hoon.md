# 해시 키 재배치(refresh) 문제

N개의 캐시 서버가 있고, 이 서버들에 부하를 균등하게 나누는 보편적 방법은 아래의 해시 함수를 사용하는 것이다.

```
serverIndex = hash(key) % N (N은 서버의 개수)
```

### 예제를 통해 알아보기

총 4대의 서버를 사용한다고 할 때 각각의 키에 대해 해시 값과 서버 인덱스를 계산한 예제이다.

| **키** | **해시**  | **해시 % 4(서버 인덱스)** |
| --- | --- | --- |
| key0 | 18358617 | 1 |
| key1 | 26143584 | 0 |
| key2 | 18131146 | 2 |
| key3 | 35863496 | 0 |
| key4 | 34085809 | 1 |
| key5 | 27581703 | 3 |
| key6 | 38164978 | 2 |
| key7 | 22530351 | 3 |

이렇게 계산된 결과를 바탕으로 서버 인덱스에 분류된다.

![Image](https://github.com/user-attachments/assets/cc13725f-c1ab-48ed-8dbd-2cab38305912)

이렇게 분류하는 방법은 서버 풀(pool)의 크기가 고정되어 있을 때와 데이터 부포가 균등할 때 잘 동작한다.

하지만 서버가 추가되거나 기존 서버가 삭제되면 문제가 생긴다.

만약 해시를 동일하게 유지하고 서버 인덱스에 변화를 줄 경우, 대부분 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 될 것이다.(대규모 캐시 미스(cache miss) 발생)

## 안정 해시(consistent hash)

키의 개수가 k, 슬롯(slot)의 개수가 n이라고 할 때, 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술이다.

### 해시 공간과 해시 링

해시 함수 f로 SHA-1을 사용, 그 함수의 출력값 범위는 x0,...xn까지라고 할 때, SHA-1의 해시 공간 범위는 0 ~ 2^160 - 1 이 되므로 x0 -> 0, xn -> x^160-1이 될 것이다.

이런 조건에서 해시 공간은 다음과 같이 표현할 수 있다.

![image](https://github.com/user-attachments/assets/1a0bd977-1c6b-4f02-9646-a625e62fcf53)

그리고 이 해시 공간을 구부려 말면 다음과 같은 해시 링(hash ring)이 만들어진다.

![image](https://github.com/user-attachments/assets/30116a0f-904b-4755-81e7-17cbe8899562)


### 해시 서버

이런 해시 함수를 이용하면 서버 IP나 이름을 이 링 위의 어떤 위치에 대응시킬 수 있다.

![image](https://github.com/user-attachments/assets/4ae4a74b-0a49-471a-a8b9-bded6c1a841e)


### 해시 키

나머지 연산(%)를 사용하지 않는 어떤 해시 함수를 사용해서 캐시할 키를 해시 링 위의 어느 지점에 배치할 수 있다.

![image](https://github.com/user-attachments/assets/7a99004b-fc7e-4bd2-8406-0af66bfeb515)


### 서버 조회

어떤 키가 저장되는 서버는, 해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버다.

따라서 key0는 서버 0에, key1은 서버 1에 저장될 것이다.

![image](https://github.com/user-attachments/assets/f3d110ef-f983-4fa0-a7fa-364db0696359)


### 서버 추가

따라서 서버를 추가하더라도 키 가운데 일부만 재배치하면 된다. 새로운 서버 4가 추가된다고 했을 때 영향을 받는(시계 방향으로 순회할 때 만나는) key1만 재배치된다.

![image](https://github.com/user-attachments/assets/9d7678ce-a5d5-4db1-a9c9-5173d61d3c56)


### 서버 제거

위의 사례와 같이 서버가 제거되면 영향을 받는 키만 재배치 된다.

![image](https://github.com/user-attachments/assets/854081df-f812-4f1a-aa43-a6443ad62b8f)


### 기본 구현법의 두 가지 문제

MIT에서 제안된 안정 해시 알고리즘의 기본 절차는 다음과 같다.

\- 서버와 키를 균등 분포 해시 함수를 사용해 해시 링에 배치한다.

\- 키의 위치에서 링을 시계 발향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버다.

이 접근법에는 두 가지 문제가 있다.

-   서버가 추가되거나 삭제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는 게 불가능하다.
    -   서버마다 할당 받는 해시 공간의 크기가 다르다.
-   키의 균등 분포를 달성하기가 어렵다.

### 가상노드

위의 문제를 해결하기 위해 제안된 기법이 가상 노드 또는 복제라 불리는 방법이다.

가상 노드는 실제 노드 또는 서버를 가리키는 노드로서, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다. 각 서버는 하나가 아닌 여러 개의 파티션을 관리하게 된다.

![image](https://github.com/user-attachments/assets/e9e38755-0b39-483f-a29e-c060bea6226e)


키의 위치로부터 시계방향으로 링을 탐색하다 만나느 최초의 가상 노드가 해당 키가 저장될 서버가 된다.

가상 노드의 개수를 늘릴수록 표준편차가 줄어들어 데이터가 고르게 분포된다. 그러나 가상 노드 데이터를 저장할 공간이 더 많이 필요하게 되므로 타협적 결정(tradeoff)이 필요하다.

### 재배치할 키 결정

서버가 추가되거나 제거될 때 어느 범위의 키들이 재배치되어야 할까?

다음과 같이 서버 4가 추가될 때 영향을 받은 범위는 s4부터 반시계 방향에 있는 첫 번째 서버 s3까지이다. 따라서 s3~s4 사이에 있는 키들을 s4로 재배치해야 한다.

![image](https://github.com/user-attachments/assets/37e784cc-107b-4035-802d-c5c03dae2893)


## 정리

안정 해시의 이점은 다음과 같다.

-   서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
-   데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다.
-   핫스팟(hotspot) 키 문제를 줄인다. 특정한 샤드(shard)에 대한 접근이 지나치게 빈번하면 서버 과부하가 생길 수 있다.
